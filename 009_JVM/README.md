##  1.JVM  简介 & 概述

###  1.1  JVM  简介 & 概述

- JVM全称：`Java Virtual Machine` ,中文译为`Java虚拟机`
- Java程序被编译成字节码，字节码再加载到`Java虚拟机`后就可以运行了，`Java虚拟机`就是`Java程序的运行环境`，更确切地说`Java虚拟机`是`Java二进制字节码`的运行环境
- JVM是java语言能够做到`一次编译到处运行`的基石。Java语言是跨平台的，跨平台是在JVM层面实现的。JVM屏蔽了字节码和底层操作系统之间的差异，对外提供一致的运行环境。JVM可以用解释的方法来执行二进制字节码，从而实现平台无关性
- JVM的一些强大之处：
  - JVM屏蔽Java代码和底层操作系统之间的差异
  - JVM提供自动内存管理机制，提供垃圾回收的功能。数组下标越界检查，其他一些语言如C\C++不提供数组下标越界检查，假如出现数组下标越界就会覆盖其他代码的内存
  - 多态是面向对象编程的基础，多态使得程序代码的可扩展性得到提升，jVM在其内部实现了多态

- JVM、jre、jdk比较：
  - jre： JVM结合一些基础类库就构成了jre,基础类库指平时用的集合类、日期类、线程类、IO类等等
  - Java虚拟机仅仅是狭义的运行环境，只有结合这些基础类库才能构成完整意义上的运行时环境
  - 在jre的基础上加上编译工具就组成了JDK。编译工具包括`javac`命令、`java`命令、`javap`等命令以及一些内存监测工具

![image-20230605203346960](https://cdn.jsdelivr.net/gh/Li-ShiLin/images/D:%5Cgithub%5Cimages202306270559190.png)

- 学习JVM的用处

  - 理解底层的实现原理，如：

    - 自动拆箱原理

    - foreach增强的实现

    - 动态代理原理


  - 定位线上问题：
    - 如响应缓慢、内存溢出


- 常见的JVM
  - JVM是一套规范，如果遵守这套规范，个人或者公司都可以开发一套JVM的实现。Oracle实现的HotSpot是最我们学习和使用比较多的一种实现。常见的实现如下图所示：
  - **本课程对JVM的讲解都是基于Oracle实现的HotSpot**

![image-20230609082705782](https://cdn.jsdelivr.net/gh/Li-ShiLin/images/D:%5Cgithub%5Cimages202306270559874.png)

###  1.2 JVM学习路线

- JVM组成：类加载器、JVM内存结构、JVM执行引擎
- JVM知识体系：一个类从Java源代码编译成Java二进制字节码，通过类加载器后被加载到JVM内存中运行。类是被放置到方法区、类创建的实例和对象被放在堆中，堆中的对象在调用方法时会用到虚拟机栈、程序计数器以及本地方法栈。方法在执行时，代码是由JVM执行引擎的解释器逐行进行执行，方法中那些被频繁调用的热点代码会被即时编译器优化后进行执行。GC垃圾回收模块对堆里面那些不再使用的对象进行一个垃圾回收。一些Java代码不方便实现的功能，必须调用底层操作系统的功能，要和操作系统打交道就需要借助本地方法接口来调用操作系统提供的一些功能和方法

![image-20230610153125959](https://cdn.jsdelivr.net/gh/Li-ShiLin/images/D:%5Cgithub%5Cimages202306270600324.png)

- 本课程学习路线：内存结构  ->  垃圾回收机制  ->  类的字节码结构、Java类编译前的优化  ->  类加载器  ->  类开始运行时的优化，涉及即时编译器的优化

##  2. JVM内存结构

###  2.1 程序计数器

Program Counter Register程序计数器 （Register: 寄存器）

右侧为Java源代码，Java源代码经过编译后生成左侧的二进制字节码，下面二进制字节码中一行行的命令就是jvm指令，JVM指令在所有操作系统上都是一样的，JVM指令是Java语言跨平台的基础。JVM指令还不能被CPU直接执行，JVM指令经过解释器的解释为机器码，机器码可以直接在CPU上执行。程序计数器的作用就是在程序执行的过程中记住下一条JVM指令执行的地址。下图的JVM指令前面的数字表示指令的内存地址，当前指令执行时，解释器就会到程序计数器中获取下一条指令的内存地址，从而不断地执行指令。JVM中的程序计数器是对物理硬件的屏蔽和抽象。在物理上，程序计数器是通过寄存器实现的，寄存器是CPU中读取速度最快的单元

![image-20230611120354233](https://cdn.jsdelivr.net/gh/Li-ShiLin/images/D:%5Cgithub%5Cimages202306270600887.png)

程序计数器作用：记住下一条jvm指令的执行地址

程序计数器特点：

- 是线程私有的
- 不会存在内存溢出

线程私有：

Java程序支持多线程运行，假如同时有多个线程在运行，CPU会有一个调度器组件给各个线程分配时间片，假如线程1在指定的时间片内没有执行完任务，CPU就会把线程1的状态暂存，并切换到其他线程执行。当线程1再次抢占到CPU时，才能执行剩余的代码



在线程切换的过程中，需要用程序计数器记住线程执行到哪了。假如线程1执行到指令`aload_1`时发生了线程切换，属于线程1的程序计数器就会记住下一条指令的执行地址。当线程1再次抢占到CPU时，线程一就会接着执行指令`aload_1`后面的指令。程序计数器是线程私有的，每个线程都有各自的程序计数器，保证了在线程切换时，能够正确地找到各种线程的下一条指令地址进行执行

![image-20230611135609183](https://cdn.jsdelivr.net/gh/Li-ShiLin/images/D:%5Cgithub%5Cimages202306270600253.png)



不会存在内存溢出：JVM中的堆、方法区都会发生内存溢出，但是程序计数器不会发生内存溢出

###  2.2 虚拟机栈

#####  2.2.1 定义

虚拟机栈定义：

Java Virtual Machine Stacks (Java 虚拟机栈)

- 每个线程运行时所需要的内存,称为虚拟机栈
- 每个栈由多个栈帧(Frame) 组成，栈帧对应着每次方法调用时所占用的内存
- 每个线程只能有一个活动栈帧, 活动栈帧对应着当前正在执行的那个方法



栈：先进后出

JVM中的虚拟机栈是线程运行时所需的内存空间，一个线程运行需要一个虚拟机栈，多个线程就需要多个虚拟机栈

一个栈内可以看作由多个栈帧组成，一个栈帧就对应着一次方法的调用。线程最终是为了执行代码，而代码都是由一个个方法组成。栈帧就是方法运行时需要的内存

方法内的参数、局部变量、返回地址等都需要占用内存，每个方法运行时都要预先将执行内存分配好

栈帧和栈是怎么联系起来的？调用某个方法时，就为该方法划分一段栈帧空间，并将该栈帧压入栈内，当该方法执行完以后，就会把其对应的栈帧弹出栈，从而释放栈帧占用的内存

假如方法1调用了方法2，方法2用调用了方法3，那这些方法对应的栈帧就会被依次压入栈内，于是一个栈内就同时存在了多个栈帧。当方法3、方法2、方法1依次执行完之后，就会依次清空栈内的栈帧

![image-20230611143643317](https://cdn.jsdelivr.net/gh/Li-ShiLin/images/D:%5Cgithub%5Cimages202306270600165.png)

演示栈帧：

```java
package cn.itcast.jvm.t1.stack;
/**
 * 演示栈帧
 */
public class Demo1_1 {
    public static void main(String[] args) throws InterruptedException {
        method1();
    }

    private static void method1() {
        method2(1, 2);
    }

    private static int method2(int a, int b) {
        int c =  a + b;
        return c;
    }
}
```











#####  2.2.2 栈内存溢出









#####  2.3.2 线程运行诊断







3.本地方法栈

4.堆

5.方法区
